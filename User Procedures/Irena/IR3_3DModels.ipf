#pragma TextEncoding = "UTF-8"
#pragma rtGlobals=3		// Use modern global access method and strict wave access.
#pragma version=1.00



//*************************************************************************\
//* Copyright (c) 2005 - 2019, Argonne National Laboratory
//* This file is distributed subject to a Software License Agreement found
//* in the file LICENSE that is included with this distribution. 
//*************************************************************************/


//1.00 first version, added code for 3Daggregate from Alex McGlassson 




//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//			3D packages, 2018-12-26
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Menu "Grow Aggregate"
	"IR3A_RunAllAgregate"			// Runs all procedures in order
	"IR3A_Print Results"		// Displays topological parameters
	"-"
	"IR3A_GrowAggregate"		// Grows aggregate
	"IR3A_FindEnds"			// Finds endpoints of aggregate
	"IR3A_End to End"			// Calculates R, df
	"IR3A_Find Paths"			// Required to calculate dmin, p
	"IR3A_Gizmo View Aggregate" //3d view
End
//******************************************************************************************************************************************************
//			Main packages as they are called from main menu. 
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
Function IR3A_MassFractalAggregate()
		//this calls Fractal aggregate controls. 
		

end
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
Function IR3A_TwoPhaseSystem()
		//this calls GUI controlling code for two-phase solid, acrding to what SAXSMorph and otherpackages are doing.  
		
end
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
Function IR3A_ImportPOVPDB()
		//this calls GUI for import of various 3D formats - POV from SAXSMorph and PDB files from GNOM.

end
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
Function IR3A_Display3DData()
		//this calls controls which can display 3D data generated by other 3D code or imported by POV/PDB importer
		//uses Gizmo
		
end
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//			3D aggregate code, modified from Alex 2018-12-26
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Function IR3A_RunAllAgregate()

	string OldDf=GetDataFolder(1)
	IR3A_AggInitialize()
	SetDataFolder root:Packages:AggregateModeling

	NVAR gGL
	NVAR gDOA
	NVAR gstick
	NVAR gPathNo
	
	variable GL=gGL, DOA=gDOA, stick=gstick, PathNo=gPathNo
	Prompt DOA, "Enter the size of the aggregate (250)"	// Degree of aggregation, z
	Prompt stick, "Enter sticking probability (1 - 100)"	// SP = 100% for DLA; less for RLA
	Prompt PathNo,"Enter number of paths (1000)."		// More paths = more accuracy
	DoPrompt/Help="Basic parameters" "Input model parameters", DOA, stick, PathNo

	gGL=GL;gDOA=DOA;gstick=stick;gPathNo=PathNo;
	// Get the starting position of the aggregate
	Make/n=(gDOA,3)/O Agg=0		// It starts at 0,0,0
	Make/n=(gDOA,4)/o endpoints
	make/N=(gDOA)/O Distances 	// Distance between existing particles & new one. Needed by MakeAgg
	variable StartTicks=ticks
	print time()+"  Started Run All" 
		IR3A_MakeAgg(gDOA,Agg,gstick)		// Agg is made with DOA particles
		IR3A_Ends(agg)
		IR3A_Reted(endpoints)
		IR3A_Path(gPathNo)
		Execute("IR3A_GizmoViewAggregate()")
	print time()+"  Finished, done in "+num2str((ticks-StartTicks)/60)+" seconds" 	
	setDataFOlder OldDf
End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

Function IR3A_GrowAggregate()
	string OldDf=GetDataFolder(1)
	IR3A_AggInitialize()
	SetDataFolder root:Packages:AggregateModeling

	NVAR gGL
	NVAR gDOA
	NVAR gstick
	variable GL=gGL, DOA=gDOA, stick=gstick
	Prompt DOA, "Enter the size of the aggregate (250)"
	Prompt stick, "Enter sticking probability (1 - 100)"
	DoPrompt/Help="Basic parameters" "Input model parameters", DOA, stick
	gGL=GL;gDOA=DOA;gstick=stick
	// Get the starting position of the aggregate
	Make/n=(gDOA,3)/O Agg=0		// It starts at 0,0,0
	make/N=(gDOA)/O Distances 	// Distance between existing particles & new one. Needed by MakeAgg
	IR3A_MakeAgg(gDOA,Agg,gstick)		// Agg is made with DOA particles
	setDataFOlder OldDf
End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
Function IR3A_AggInitialize()

	string OldDf=GetDataFolder(1)
	NewDataFolder/O/S root:Packages
	NewDataFolder/O/S root:Packages:AggregateModeling
	variable/g gGL, gDOA, gstick, gPathNo
	IR3A_MakeNBROffsetList()
	setDataFOlder OldDf
end
//******************************************************************************************************************************************************
//Function ProfilingRun()
//	string OldDf=GetDataFolder(1)
//	SetDataFolder root:Packages:AggregateModeling
//	AggMod_Initialize()
//
//	NVAR gGL
//	NVAR gDOA
//	NVAR gstick
//	NVAR gPathNo
//	
//	//variable GL=gGL, DOA=gDOA, stick=gstick, PathNo=gPathNo
//	//Prompt DOA, "Enter the size of the aggregate (250)"	// Degree of aggregation, z
//	//Prompt stick, "Enter sticking probability (1 - 100)"	// SP = 100% for DLA; less for RLA
//	//Prompt PathNo,"Enter number of paths (10000)."		// More paths = more accuracy
//	//DoPrompt/Help="Basic parameters" "Input model parameters", DOA, stick, PathNo
//
//	gGL=500;gDOA=500;gstick=40;gPathNo=500;
//	// Get the starting position of the aggregate
//	Make/n=(gDOA,3)/O Agg=0		// It starts at 0,0,0
//	Make/n=(gDOA,4)/O endpoints
//	make/N=(gDOA)/O Distances 	// Distance between existing particles & new one. Needed by MakeAgg
//	variable StartTicks=ticks
//	print "Started Run All" 
//		MakeAgg(gDOA,Agg,gstick)		// Agg is made with DOA particles
//		Ends(agg)
//		Reted(endpoints)
//		Path(gPathNo)
//		Execute("GizmoViewAggregate()")
//	print "Finished, done in "+num2str((ticks-StartTicks)/60)+" seconds" 	
//	setDataFOlder OldDf
//
//end

//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

Function IR3A_MakeAgg(DOA,Agg,stick)
	variable DOA,stick
	wave Agg
	
	string OldDf=GetDataFolder(1)
	SetDataFolder root:Packages:AggregateModeling
	Wave Distances
	//Make/n=(26,3)/Free nghbr		// 26-way neighbor-checking
	make/Free/N=(dimsize(Agg,0),3) CurSite
	make/Free/N=(dimsize(Agg,0)) tmpCol
	variable chcnt=1,px,py,pz,aggct=1,cnt,con,stuck,dim,choice,wall,Rd=16,GL=16,farpoint,index=0, tmpVal
	variable/g gattempt=1
	NVAR gGL
	PauseUpdate
	Do
		// resize box based on size of Agg
		index=0
		do
			if(Agg[aggct-1][index]>farpoint)
				farpoint=Agg[aggct-1][index]
			endif
			index+=1
		while(index<3)
		GL=2*abs(farpoint)+10;gGL=GL		
		// initialize particle on a random wall of the box
		wall=0;choice=0
		if(aggct<64)	// choose random wall on smaller box for low aggct
			do
				wall=abs(round(enoise(7)))
			while(wall==0 || wall==7)
			if(wall==1)
				px=-1+Rd/2;py=round(enoise(Rd/2));pz=round(enoise(Rd/2))
			endif
			if(wall==2)
				px=1-Rd/2;py=round(enoise(Rd/2));pz=round(enoise(Rd/2))
			endif
			if(wall==3)
				px=round(enoise(Rd/2));py=-1+Rd/2;pz=round(enoise(Rd/2))
			endif
			if(wall==4)
				px=round(enoise(Rd/2));py=1-Rd/2;pz=round(enoise(Rd/2))
			endif
			if(wall==5)
				px=round(enoise(Rd/2));py=round(enoise(Rd/2));pz=-1+Rd/2
			endif
			if(wall==6)
				px=round(enoise(Rd/2));py=round(enoise(Rd/2));pz=1-Rd/2
			endif
		else		// choose random wall on normal box
			do
				wall=abs(round(enoise(7)))
			while(wall==0 || wall==7)
			if(wall==1)
				px=-1+GL/2;py=round(enoise(GL/2));pz=round(enoise(GL/2))
			endif
			if(wall==2)
				px=1-GL/2;py=round(enoise(GL/2));pz=round(enoise(GL/2))
			endif
			if(wall==3)
				px=round(enoise(GL/2));py=-1+GL/2;pz=round(enoise(GL/2))
			endif
			if(wall==4)
				px=round(enoise(GL/2));py=1-GL/2;pz=round(enoise(GL/2))
			endif
			if(wall==5)
				px=round(enoise(GL/2));py=round(enoise(GL/2));pz=-1+GL/2
			endif
			if(wall==6)
				px=round(enoise(GL/2));py=round(enoise(GL/2));pz=1-GL/2
			endif
		endif
		// Move the particle until it a) hits the chain or b) leaves the box, if b) you need to have it reenter the box at a mirror position.
		do	//move 1 step in any direction
			//choice=0
			//do
			//choice=abs(round(enoise(7)))
			choice = floor(1 + mod(abs(enoise(100*6)),6))	
			//while(choice==0 || choice==7)
			if(choice==1)
				px+=1
			endif
			if(choice==2)	
				px-=1
			endif
			if(choice==3)	
				py+=1
			endif
			if(choice==4)
				py-=1
			endif
			if(choice==5)	
				pz+=1
			endif
			if(choice==6)	
				pz-=1
			endif
			//if you leave the box (a likely event) then go to the other side and reenter the box (mirror)
			If(aggct<64)	// use smaller box for low number of particles
				if(px>Rd/2)
					px=px-Rd
				endif
				if(px<-Rd/2)
					px=px+Rd
				endif
				if(py>Rd/2)
					py=py-Rd
				endif
				if(py<-Rd/2)
					py=py+Rd
				endif
				if(pz>Rd/2)
					pz=pz-Rd
				endif
				if(pz<-Rd/2)
					pz=pz+Rd
				endif	
			else		// use normal box for higher number of particles
				if(px>GL/2)
					px=px-GL
				endif
				if(px<-GL/2)
					px=px+GL
				endif
				if(py>GL/2)
					py=py-GL
				endif
				if(py<-GL/2)
					py=py+GL
				endif
				if(pz>GL/2)
					pz=pz-GL
				endif
				if(pz<-GL/2)
					pz=pz+GL
				endif
			endif
			cnt=0;con=0
																			// check how many neighboring sites are occupied
																			//replacing this brute force search below with distance calculation (1) speeds up total time on test case from ~90s to 5-9 sec.  
																			//			do
																			//				dim=0
																			//				do
																			//					if(nghbr[dim][0]==agg[cnt][0]&&nghbr[dim][1]==agg[cnt][1]&&nghbr[dim][2]==agg[cnt][2])
																			//						con+=1
																			//					endif
																			//					dim+=1
																			//				while(dim<26)
																			//				cnt+=1
																			//			while(cnt<aggct)
																			// (1) replace above brute force with disctance calculation below, this seems fastest way: 
																			//				make/Free/O/N=(DimSize(agg,0)) Distances 			//mocved to teh top to avoid making it again...
																			//				Distances[] = sqrt( (px-agg[p][0])^2+(py-agg[p][1])^2+(pz-agg[p][2])^2)		//	this is distance, but why sqrt? Save time... 
			//this is by far the longest step in the whole procedure
			//basically, we are looking for how many neighbors px,py,pz position has 
			//this is already much better than before, but it would really be nice to find better way of doing this. We are doing this A LOT. With every particle move, so it is done many, many times. 
			Multithread Distances[0,aggct] = ((px-agg[p][0])^2 + (py-agg[p][1])^2 + (pz-agg[p][2])^2)		//	Multithread helps, in my test case reduces time by ~60%
																			//this is slower... 
																			//CurSite[][0]=px
																			//CurSite[][1]=py
																			//CurSite[][2]=pz
																			//MatrixOp/O/Free/NTHR=0 Distances = sumRows(powR((agg-CurSite),2))
			Histogram/B={0.5,2.6,2}/R=[0,aggct]/Dest=DistHist Distances			//histogram - bin[0] is from 0.5 - 3.1, max allowed distance^2 is 3
				con = DistHist[0]																	// this is number of nearest neighbors with distance below sqrt(3)
																			//another method, suggested by WM, but is slower, much slower ...
																			//			CurSite[0][0]=px
																			//			CurSite[0][1]=py
																			//			CurSite[0][2]=pz
																			//			MatrixOp/Free TestWv = catRows(CurSite,agg)
																			//			FPClustering /DSO TestWv
																			//			Wave M_DistanceMap
																			//			//Edit/K=1 root:M_DistanceMap
																			//			MatrixOp/Free Distances=row(M_DistanceMap,0)
																			//			//Edit/K=1 root:Distances
																			//			Histogram/B={0.1,1.8,2}/Dest=DistHist Distances
																			//			//Edit/K=1 root:DistHist
																			//			con = DistHist[0]
																			// end of neighbor counting. 
			//choice=0
			if(con>=1)	// particle can stick if there is at least 1 neighbor
				do
					//do	// apply sticking probability between 1% and 100%
					choice=floor(1 + mod(abs(enoise(100*99)),100))		//generates random integer from 1 to 99
					//while(choice==0 || choice==102)
					choice-=1
					gattempt+=1
					if(choice<=stick)
						stuck=1
						con=0
					else
						con-=1
						stuck=0
					endif
				while(con>=1)
			//keep moving if alone or rejected by sticking probability
			else
				stuck=0
			endif
			//if the particle sticks, add it to the aggregate
			variable steps=trunc(DOA/10)
			steps = max(steps,100)
			if(stuck==1)
				if(mod(aggct,steps)<1) ///round(DOA/50))==aggct/round(DOA/50))
					Print time()+"  Added "+num2str(aggct)+" particles to the aggregate  "	//takes needless time.. 
				endif
				Agg[aggct][0]=px
				Agg[aggct][1]=py
				Agg[aggct][2]=pz
				aggct+=1
			endif
		while(stuck==0)
		stuck=0 //reset stuck flag
	While(aggct<DOA)	// stop aggregate growth when there are DOA particles in Agg
	Print time()+"  Created Aggregate with "+num2str(aggct)+" particles in it" 	//takes needless time.. 
	setDataFOlder OldDf

End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//		nghbr[0][0]=agg[cnt][0]+1;nghbr[0][1]=agg[cnt][1];nghbr[0][2]=agg[cnt][2]
//		nghbr[1][0]=agg[cnt][0]-1;nghbr[1][1]=agg[cnt][1];nghbr[1][2]=agg[cnt][2]
//		nghbr[2][0]=agg[cnt][0];nghbr[2][1]=agg[cnt][1]+1;nghbr[2][2]=agg[cnt][2]
//		nghbr[3][0]=agg[cnt][0];nghbr[3][1]=agg[cnt][1]-1;nghbr[3][2]=agg[cnt][2]
//		nghbr[4][0]=agg[cnt][0]+1;nghbr[4][1]=agg[cnt][1]+1;nghbr[4][2]=agg[cnt][2]
//		nghbr[5][0]=agg[cnt][0]-1;nghbr[5][1]=agg[cnt][1]-1;nghbr[5][2]=agg[cnt][2]
//		nghbr[6][0]=agg[cnt][0]-1;nghbr[6][1]=agg[cnt][1]+1;nghbr[6][2]=agg[cnt][2]
//		nghbr[7][0]=agg[cnt][0]+1;nghbr[7][1]=agg[cnt][1]-1;nghbr[7][2]=agg[cnt][2]
//		nghbr[8][0]=agg[cnt][0];nghbr[8][1]=agg[cnt][1];nghbr[8][2]=agg[cnt][2]+1
//		nghbr[9][0]=agg[cnt][0]+1;nghbr[9][1]=agg[cnt][1];nghbr[9][2]=agg[cnt][2]+1
//		nghbr[10][0]=agg[cnt][0]-1;nghbr[10][1]=agg[cnt][1];nghbr[10][2]=agg[cnt][2]+1
//		nghbr[11][0]=agg[cnt][0];nghbr[11][1]=agg[cnt][1]+1;nghbr[11][2]=agg[cnt][2]+1
//		nghbr[12][0]=agg[cnt][0];nghbr[12][1]=agg[cnt][1]-1;nghbr[12][2]=agg[cnt][2]+1
//		nghbr[13][0]=agg[cnt][0]+1;nghbr[13][1]=agg[cnt][1]+1;nghbr[13][2]=agg[cnt][2]+1
//		nghbr[14][0]=agg[cnt][0]-1;nghbr[14][1]=agg[cnt][1]-1;nghbr[14][2]=agg[cnt][2]+1
//		nghbr[15][0]=agg[cnt][0]-1;nghbr[15][1]=agg[cnt][1]+1;nghbr[15][2]=agg[cnt][2]+1
//		nghbr[16][0]=agg[cnt][0]+1;nghbr[16][1]=agg[cnt][1]-1;nghbr[16][2]=agg[cnt][2]+1
//		nghbr[17][0]=agg[cnt][0];nghbr[17][1]=agg[cnt][1];nghbr[17][2]=agg[cnt][2]-1
//		nghbr[18][0]=agg[cnt][0]+1;nghbr[18][1]=agg[cnt][1];nghbr[18][2]=agg[cnt][2]-1
//		nghbr[19][0]=agg[cnt][0]-1;nghbr[19][1]=agg[cnt][1];nghbr[19][2]=agg[cnt][2]-1
//		nghbr[20][0]=agg[cnt][0];nghbr[20][1]=agg[cnt][1]+1;nghbr[20][2]=agg[cnt][2]-1
//		nghbr[21][0]=agg[cnt][0];nghbr[21][1]=agg[cnt][1]-1;nghbr[21][2]=agg[cnt][2]-1
//		nghbr[22][0]=agg[cnt][0]+1;nghbr[22][1]=agg[cnt][1]+1;nghbr[22][2]=agg[cnt][2]-1
//		nghbr[23][0]=agg[cnt][0]-1;nghbr[23][1]=agg[cnt][1]-1;nghbr[23][2]=agg[cnt][2]-1
//		nghbr[24][0]=agg[cnt][0]-1;nghbr[24][1]=agg[cnt][1]+1;nghbr[24][2]=agg[cnt][2]-1
//		nghbr[25][0]=agg[cnt][0]+1;nghbr[25][1]=agg[cnt][1]-1;nghbr[25][2]=agg[cnt][2]-1
		// check neighboring points; add 1 connection for each neighboring point
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
Proc IR3A_FindEnds()	
	Silent 1
	Ends(agg)
End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Function IR3A_Ends(agg)
	wave agg

	string OldDf=GetDataFolder(1)
	SetDataFolder root:Packages:AggregateModeling
	NVAR gDOA

	variable cnt=0,ncnt=0,con=0,endcnt=0,dim=0
	Make/n=(26,3)/Free nghbr
	Wave/Z nghbrOfsetList
	if(!WaveExists(	nghbrOfsetList))
		IR3A_MakeNBROffsetList()
	endif
	Make/n=(gDOA,4)/o endpoints
	do
		// define neighbors for each point in agg
		nghbr = nghbrOfsetList[p][q] + agg[cnt][q]
		ncnt=0;con=0
		do
			dim=0
			do
				if(nghbr[dim][0]==agg[ncnt][0]&&nghbr[dim][1]==agg[ncnt][1]&&nghbr[dim][2]==agg[ncnt][2])
					con+=1
				endif
				dim+=1
			while(dim<26)
			ncnt+=1
		while(ncnt<gDOA)
		// it's an endpoint if there is exactly 1 neighboring point
		// record position in x, y, z and then record index in agg
		if(con==1)
			endpoints[endcnt][0]=agg[cnt][0];endpoints[endcnt][1]=agg[cnt][1];endpoints[endcnt][2]=agg[cnt][2];endpoints[endcnt][3]=cnt
			endcnt+=1
		endif
		cnt+=1
		//Print cnt
	while(cnt<gDOA)
	//remove extra rows from endpoints wave
	DeletePoints endcnt,gDOA, endpoints
	setDataFOlder OldDf
	Print time()+"  Finished running Find Ends" 	//takes needless time.. 
	
End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

Proc IR3A_EndtoEnd()	
	Silent 1
	Reted(endpoints)
End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

Function IR3A_Reted(endpoints)
	wave endpoints
	// calculate longest end-to-end distance for each combination of endpoints and its square for weight-averaged end-to-end distance	
	string OldDf=GetDataFolder(1)
	SetDataFolder root:Packages:AggregateModeling
	NVAR gDOA
	variable/g gR,gdf
	variable endnum=DimSize(endpoints,0), numcomb=binomial(endnum,2), cnt=0,endadd=0,ecnt=1,REnd=0,Rsum=0,Retend=0,RAve=0,rem=endnum
	Make/n=(numcomb,1)/o enddist=0
	Make/n=(endnum-3,7)/o Rlarge=0
	do	// determine end-to-end distance between all endpoints
		do
			enddist[endadd]=sqrt((endpoints[cnt][0]-endpoints[ecnt][0])^2+(endpoints[cnt][1]-endpoints[ecnt][1])^2+(endpoints[cnt][2]-endpoints[ecnt][2])^2)
			if(endnum-cnt>3)	
				if(enddist[endadd]>Rlarge[cnt][6])
					Rlarge[cnt][0]=endpoints[cnt][0];Rlarge[cnt][1]=endpoints[cnt][1];Rlarge[cnt][2]=endpoints[cnt][2]
					Rlarge[cnt][3]=endpoints[ecnt][0];Rlarge[cnt][4]=endpoints[ecnt][1];Rlarge[cnt][5]=endpoints[ecnt][2]
					Rlarge[cnt][6]=enddist[endadd]
				endif
			endif
			ecnt+=1
			endadd+=1
		while(ecnt<endnum)
		cnt+=1
		ecnt=cnt+1
	while(ecnt<endnum)
	cnt=0
	do	// calculate longest end-to-end distance for each combination of endpoints and its square for weight-averaged end-to-end distance
		REnd+=(Rlarge[cnt][6])*(Rlarge[cnt][6])
		RSum+=(Rlarge[cnt][6])
		cnt+=1
	while(cnt<endnum-3)
	RAve=RSum/cnt
	REnd/=RSum
	cnt=0
	// Print and record R, df
	Print "R = "+num2str(REnd)
	Print "df= "+num2str(log(gDOA)/log(REnd))
	gR=Rend;gdf=log(gDOA)/log(REnd)

	setDataFOlder OldDf
End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

Proc IR3A_FindPaths(PathNo)	
	variable/g gPathNo
	variable PathNo=gPathNo
	Prompt PathNo,"Enter number of paths (10000)."
	Silent 1
	gPathNo=PathNo
	Path(PathNo)
End


//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

Function IR3A_MakeNBROffsetList()

	Make/n=(26,3)/O nghbrOfsetList
	Wave nghbrOfsetList = nghbrOfsetList
		nghbrOfsetList[0][0] =+1;nghbrOfsetList[0][1] = 0;nghbrOfsetList[0][2] = 0
		nghbrOfsetList[1][0] =-1;nghbrOfsetList[1][1] = 0;nghbrOfsetList[1][2] = 0
		nghbrOfsetList[2][0] = 0;nghbrOfsetList[2][1] =+1;nghbrOfsetList[2][2] = 0
		nghbrOfsetList[3][0] = 0;nghbrOfsetList[3][1] =-1;nghbrOfsetList[3][2] = 0
		nghbrOfsetList[4][0] =+1;nghbrOfsetList[4][1] =+1;nghbrOfsetList[4][2] = 0
		nghbrOfsetList[5][0] =-1;nghbrOfsetList[5][1] =-1;nghbrOfsetList[5][2] = 0
		nghbrOfsetList[6][0] =-1;nghbrOfsetList[6][1] =+1;nghbrOfsetList[6][2] = 0
		nghbrOfsetList[7][0] =+1;nghbrOfsetList[7][1] =-1;nghbrOfsetList[7][2] = 0
		nghbrOfsetList[8][0] = 0;nghbrOfsetList[8][1] = 0;nghbrOfsetList[8][2] =+1
		nghbrOfsetList[9][0] =+1;nghbrOfsetList[9][1] = 0;nghbrOfsetList[9][2] =+1
		nghbrOfsetList[10][0]=-1;nghbrOfsetList[10][1]= 0;nghbrOfsetList[10][2]=+1
		nghbrOfsetList[11][0]= 0;nghbrOfsetList[11][1]=+1;nghbrOfsetList[11][2]=+1
		nghbrOfsetList[12][0]= 0;nghbrOfsetList[12][1]=-1;nghbrOfsetList[12][2]=+1
		nghbrOfsetList[13][0]=+1;nghbrOfsetList[13][1]=+1;nghbrOfsetList[13][2]=+1
		nghbrOfsetList[14][0]=-1;nghbrOfsetList[14][1]=-1;nghbrOfsetList[14][2]=+1
		nghbrOfsetList[15][0]=-1;nghbrOfsetList[15][1]=+1;nghbrOfsetList[15][2]=+1
		nghbrOfsetList[16][0]=+1;nghbrOfsetList[16][1]=-1;nghbrOfsetList[16][2]=+1
		nghbrOfsetList[17][0]= 0;nghbrOfsetList[17][1]= 0;nghbrOfsetList[17][2]=-1
		nghbrOfsetList[18][0]=+1;nghbrOfsetList[18][1]= 0;nghbrOfsetList[18][2]=-1
		nghbrOfsetList[19][0]=-1;nghbrOfsetList[19][1]= 0;nghbrOfsetList[19][2]=-1
		nghbrOfsetList[20][0]= 0;nghbrOfsetList[20][1]=+1;nghbrOfsetList[20][2]=-1
		nghbrOfsetList[21][0]= 0;nghbrOfsetList[21][1]=-1;nghbrOfsetList[21][2]=-1
		nghbrOfsetList[22][0]=+1;nghbrOfsetList[22][1]=+1;nghbrOfsetList[22][2]=-1
		nghbrOfsetList[23][0]=-1;nghbrOfsetList[23][1]=-1;nghbrOfsetList[23][2]=-1
		nghbrOfsetList[24][0]=-1;nghbrOfsetList[24][1]=+1;nghbrOfsetList[24][2]=-1
		nghbrOfsetList[25][0]=+1;nghbrOfsetList[25][1]=-1;nghbrOfsetList[25][2]=-1

end
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Function IR3A_Path(PathNo)
	variable PathNo

	string OldDf=GetDataFolder(1)
	SetDataFolder root:Packages:AggregateModeling
	print time()+"  Started parameters evaluation, Calculating...   this takes longest time for these functions "
	wave agg, endpoints
	NVAR gDOA,gattempt
	variable minPathLengthAccepted
	minPathLengthAccepted = floor(min(gDOA^(1/2), 20))		//minimum length opf path accpeted as evaluation path, for large particles original value is crazily large. 
	Make/n=(26,3)/Free nghbr
	Wave/Z nghbrOfsetList
	if(!WaveExists(nghbrOfsetList ))
		IR3A_MakeNBROffsetList()
	endif
	Make /n=(gDOA,26)/O NeighborList=nan
	Make/n=(gDOA,1)/Free Pathing=nan
	Make/n=(PathNo,7)/Free Paths=nan
	variable endnum=DimSize(endpoints,0), choice=0, cnt=0,ncnt=0,nnum=0,dim=0,con=0,pcnt=0,nans=0,flag=0,ecnt=0,highp,p1,p2,mom1,mom2,startpoint
	Make/n=(endnum,1)/O LongPath=0
	variable i
	MatrixOp/Free EndPointsDistances=col(endpoints,3)
	variable startTime=ticks
	For(cnt=0;cnt<gDOA;cnt+=1)
		nghbr = nghbrOfsetList[p][q] + agg[cnt][q]					//this generates list of 26 neighbor positions, if any, around the agg[cnt] particle
		nnum=0
		For(ncnt=0;ncnt<gDOA;ncnt+=1)
			For(dim=0;dim<26;dim+=1)
				if(nghbr[dim][0]==agg[ncnt][0]&&nghbr[dim][1]==agg[ncnt][1]&&nghbr[dim][2]==agg[ncnt][2])
					NeighborList[cnt][nnum]=ncnt			//cnt is external loop, cnt = 0 ...gDOA
					nnum+=1
				endif
			endfor
		endfor
	endfor
	cnt=0
	do	// snake through paths
		pcnt=0
		startpoint=floor(mod(abs(enoise(100*(endnum-1))),endnum))		//generates random integer from 0 to endnum
		// record starting position and starting index in agg
		Paths[cnt][0]=endpoints[startpoint][0]
		Paths[cnt][1]=endpoints[startpoint][1]
		Paths[cnt][2]=endpoints[startpoint][2]
		Pathing[0]=endpoints[startpoint][3]
		choice=0;con=0
		do	//pick a random neighbor from list
			ncnt=0
			nans=0
			flag=0
			//this is faster... 	
			For(i=0;i<8;i+=1)
				if(numtype(NeighborList[Pathing[pcnt]][i])==2)
					nans=8-i
					break
				endif
			endfor
			variable target= 8-nans-1
			choice=floor(mod(abs(enoise(100*target)),target+1))		//generates random number from non NaNs entries... 		
			ncnt=0
			do	// check to see if value already in path
				if(NeighborList[Pathing[pcnt]][choice]==Pathing[ncnt])
					flag+=1
				endif
				ncnt+=1
			while(ncnt<pcnt)
			if(flag>=2)	// is there a loop in the aggregate?
				con=1
			else		// add normally
				pcnt+=1
				Pathing[pcnt]=NeighborList[Pathing[pcnt-1]][choice]
			endif
			ncnt=1
			ecnt=0
			// this is about 2x faster...  EndPointsDistances was created above just once, it does not change. 
			FindValue /V=(Pathing[pcnt])/T=0.1 EndPointsDistances
			if(V_value>-0.1)
				con=1
			endif
			// (2) done... 			
		while(con!=1)
		if(pcnt>minPathLengthAccepted) 				// only interested in longer paths that span aggregate; throws away short paths
			Paths[cnt][3]=agg[Pathing[pcnt]][0];Paths[cnt][4]=agg[Pathing[pcnt]][1];Paths[cnt][5]=agg[Pathing[pcnt]][2];Paths[cnt][6]=pcnt+1
			if(Paths[cnt][6]>LongPath[startpoint])
				LongPath[startpoint]=Paths[cnt][6]	
			endif
			cnt+=1
			//print "Evaluated path length of "+num2str(pcnt)
		else
			//print "Discarded path length of "+num2str(pcnt)
			continue
		endif
		if(mod(cnt,500)==0) 
			Print time()+"  Working... Evaluated "+num2str(cnt)+" Paths through the system"	//takes needless time.. 
		endif
	while(cnt<PathNo)
	ncnt=0;highp=0;p1=0;p2=0
	do	// determine weight-averaged percolation pathway
		if(LongPath[ncnt]>highp)
			highp=LongPAth[ncnt]
		endif
		p1+=(LongPath[ncnt])
		p2+=(LongPath[ncnt])*(LongPath[ncnt])
		ncnt+=1
	while(ncnt<endnum)
	mom2=round(p2/p1);mom1=round(p1/endnum)
	// print results
	NVAR gdf, gR
	variable/g gp = mom2,gc=ln(gDOA)/ln(gp),gdmin=gdf/gc,gs=round(exp(ln(gDOA)/gdmin))
	Print "R= "+num2str(gR)
	Print "z = "+num2str(gDOA)
	Print "p= "+num2str(gp)
	Print "s = "+num2str(gs)
	Print "df = "+num2str(gdf)
	Print "dmin = "+num2str(gdmin)
	Print "c = "+num2str(gc)
	Print "True Sticking Probability = "+num2str(100*gDOA/gattempt)+"%"
	setDataFOlder OldDf
End

Proc IR3A_PrintResults()
	Silent 1
	GetResults()
End

Function IR3A_GetResults()
	string OldDf=GetDataFolder(1)
	SetDataFolder root:Packages:AggregateModeling
	NVAR gDOA,gp,gdf,gdmin,gc,gs,gattempt
	gc=ln(gDOA)/ln(gp);gdmin=gdf/gc;gs=round(exp(ln(gDOA)/gdmin))
	Print "R= "+num2str(gDOA^gdf)
	Print "df = "+num2str(gdf)
	Print "z = "+num2str(gDOA)
	Print "p= "+num2str(gp)
	Print "s = "+num2str(gs)
	Print "dmin = "+num2str(gdmin)
	Print "c = "+num2str(gc)
	Print "True Sticking Probability = "+num2str(100*gDOA/gattempt)+"%"
	setDataFOlder OldDf
End


Window IR3A_GizmoViewAggregate() : GizmoPlot

	variable mnd = IR3A_GetAggMaxSize(root:Packages:AggregateModeling:Agg)
	variable boxSize=mnd+2		//make the box larger... 
	DoWIndow IR3A_GizmoViewAggregate
	if(V_Flag)
		DoWIndow/F IR3A_GizmoViewAggregate
		ModifyGizmo setOuterBox={-1*boxSize,boxSize,-1*boxSize,boxSize,-1*boxSize,boxSize}
		ModifyGizmo scalingOption=0
		ModifyGizmo modifyObject=Particle,objectType=Sphere,property={radius,1/mnd}
	
	else
		PauseUpdate; Silent 1		// building window...
		// Building Gizmo 7 window...
		NewGizmo/K=1/T="Aggregate View"/W=(35,45,550,505)
		ModifyGizmo startRecMacro=700
		AppendToGizmo Scatter=root:Packages:AggregateModeling:Agg,name=scatter0
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ scatterColorType,0}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ markerType,0}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ sizeType,0}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ rotationType,0}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ Shape,2}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ size,1}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ color,1,0,0,1}
		//sphere as object definition:
		AppendToGizmo sphere={1/mnd,25,25},name=Particle
		ModifyGizmo modifyObject=Particle,objectType=Sphere,property={colorType,1}
		ModifyGizmo modifyObject=Particle,objectType=Sphere,property={color,0.000015,0.600000,0.304250,1.000000}
		AppendToGizmo attribute diffuse={0.5,0.5,0.5,1,1032},name=diffuse0
		ModifyGizmo attributeType=diffuse,modifyAttribute={diffuse0,0.733333,0.733333,0.733333,1,1032}
		ModifyGizmo modifyObject=Particle,objectType=Sphere,property={radius,1/mnd}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ Shape,7}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ objectName,Particle}
		AppendToGizmo Axes=boxAxes,name=axes0
		ModifyGizmo ModifyObject=axes0,objectType=Axes,property={-1,axisScalingMode,1}
		ModifyGizmo ModifyObject=axes0,objectType=Axes,property={-1,axisColor,0,0,0,1}
		ModifyGizmo ModifyObject=axes0,objectType=Axes,property={0,ticks,3}
		ModifyGizmo ModifyObject=axes0,objectType=Axes,property={1,ticks,3}
		ModifyGizmo ModifyObject=axes0,objectType=Axes,property={2,ticks,3}
		ModifyGizmo modifyObject=axes0,objectType=Axes,property={-1,Clipped,0}
		AppendToGizmo light=Directional,name=LightFor3dView
		ModifyGizmo modifyObject=LightFor3dView,objectType=light,property={ position,0.000000,0.000000,-1.000000,0.000000}
		ModifyGizmo modifyObject=LightFor3dView,objectType=light,property={ direction,0.000000,0.000000,-1.000000}
		ModifyGizmo modifyObject=LightFor3dView,objectType=light,property={ ambient,0.400000,0.400000,0.400000,1.000000}
		ModifyGizmo modifyObject=LightFor3dView,objectType=light,property={ specular,1.000000,1.000000,1.000000,1.000000}
		ModifyGizmo modifyObject=LightFor3dView,objectType=light,property={ diffuse,0.933333,0.933333,0.933333,1.000000}
		ModifyGizmo modifyObject=LightFor3dView,objectType=light,property={ position,-0.6392,0.7354,0.2250,0.0000}
		ModifyGizmo modifyObject=LightFor3dView,objectType=light,property={ direction,-0.6392,0.7354,0.2250}
		ModifyGizmo setDisplayList=0, object=LightFor3dView
		ModifyGizmo setDisplayList=1, object=scatter0
		ModifyGizmo setDisplayList=2, object=axes0
		ModifyGizmo currentGroupObject=""
		//ModifyGizmo SETQUATERNION={0.535993,-0.191531,-0.283415,0.771818}
		//now scale this thing... 
		ModifyGizmo setOuterBox={-1*boxSize,boxSize,-1*boxSize,boxSize,-1*boxSize,boxSize}
		ModifyGizmo scalingOption=0
		//give user tools to work with
		ModifyGizmo showInfo
		ModifyGizmo infoWindow={5,550,822,320}
		ModifyGizmo resumeUpdates
		ModifyGizmo endRecMacro
		ModifyGizmo SETQUATERNION={-0.041312,-0.884834,-0.102589,0.452588}

	endif
EndMacro

Function IR3A_GetAggMaxSize(Agg)
	wave Agg
	
	WaveStats/Q Agg

	variable MaxNeeded=max(V_max, abs(V_min) )
	
	return MaxNeeded
end