#pragma TextEncoding = "UTF-8"
#pragma rtGlobals=3		// Use modern global access method and strict wave access.
#pragma version=1.00

Constant IR3AMassFrAggVersionNumber = 1.00

//*************************************************************************\
//* Copyright (c) 2005 - 2019, Argonne National Laboratory
//* This file is distributed subject to a Software License Agreement found
//* in the file LICENSE that is included with this distribution. 
//*************************************************************************/


//1.00 first version, added code for 3Daggregate from Alex McGlassson 




//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//			3D packages, 2018-12-26
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


//Menu "Grow Aggregate"
//	"IR3A_RunAllAgregate"			// Runs all procedures in order
//	"IR3A_Print Results"		// Displays topological parameters
//	"-"
//	"IR3A_GrowAggregate"		// Grows aggregate
//	"IR3A_FindEnds"			// Finds endpoints of aggregate
//	"IR3A_End to End"			// Calculates R, df
//	"IR3A_Find Paths"			// Required to calculate dmin, p
//	"IR3A_Gizmo View Aggregate",  //3d view
//End
//******************************************************************************************************************************************************
//			Main packages as they are called from main menu. 
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
Function IR3A_MassFractalAggregate()
		//this calls Fractal aggregate controls. 
	DoWIndow FractalAggregatePanel
	if(V_Flag)
		DoWIndow/K FractalAggregatePanel
	endif
	IN2G_CheckScreenSize("height",670)
	IR3A_InitializeMassFractAgg()
	IR3A_FractalAggregatePanel()
	ING2_AddScrollControl()
	IR1_UpdatePanelVersionNumber("FractalAggregatePanel", IR3AMassFrAggVersionNumber,1)
		

end
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
Function IR3A_TwoPhaseSystem()
		//this calls GUI controlling code for two-phase solid, acrding to what SAXSMorph and otherpackages are doing.  
		
end
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
Function IR3A_ImportPOVPDB()
		//this calls GUI for import of various 3D formats - POV from SAXSMorph and PDB files from GNOM.

end
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
Function IR3A_Display3DData()
		//this calls controls which can display 3D data generated by other 3D code or imported by POV/PDB importer
		//uses Gizmo
		
end
//******************************************************************************************************************************************************
//			Utility functions
//******************************************************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************
//*****************************************************************************************************************

Function IR3A_MainCheckVersion()	
	//this needs to get more of these lines for each tool/panel... 
	DoWindow FractalAggregatePanel
	if(V_Flag)
		if(!IR1_CheckPanelVersionNumber("FractalAggregatePanel", IR3AMassFrAggVersionNumber))
			DoAlert /T="The Mass Fractal Aggregate panel was created by incorrect version of Irena " 1, "Mass Fractal Aggregate may need to be restarted to work properly. Restart now?"
			if(V_flag==1)
				DoWindow/K FractalAggregatePanel
 				IR3A_MassFractalAggregate()
			else		//at least reinitialize the variables so we avoid major crashes...
				IR3A_InitializeMassFractAgg()
			endif
		endif
	endif
end
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//			3D aggregate code, modified from Alex 2018-12-26
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Function IR3A_CalculateAllMassFractAgreg()

	string OldDf=GetDataFolder(1)
	IR3A_InitializeMassFractAgg()
	SetDataFolder root:Packages:AggregateModeling
	DoWindow MassFractalAggregateView
	if(V_Flag)
		DoWIndow/K MassFractalAggregateView
	endif
	
	NVAR DegreeOfAggregation=root:Packages:AggregateModeling:DegreeOfAggregation
	NVAR StickingProbability=root:Packages:AggregateModeling:StickingProbability
	NVAR NumberOfTestPaths=root:Packages:AggregateModeling:NumberOfTestPaths
	
//	variable DegreeOfAggregationL=DegreeOfAggregation, StickingProbabilityL=StickingProbability, NumberOfTestPathsL=NumberOfTestPaths
//	Prompt DegreeOfAggregationL, "Enter the size of the aggregate (250)"	// Degree of aggregation, z
//	Prompt StickingProbabilityL, "Enter StickingProbabilitying probability (1 - 100)"	// SP = 100% for DLA; less for RLA
//	Prompt NumberOfTestPathsL,"Enter number of paths (1000)."		// More paths = more accuracy
//	DoPrompt/Help="Basic parameters" "Input model parameters", DegreeOfAggregationL, StickingProbabilityL, NumberOfTestPathsL

//	DegreeOfAggregation=DegreeOfAggregationL
//	StickingProbability=StickingProbabilityL
//	NumberOfTestPaths=NumberOfTestPathsL
	// Get the starting position of the aggregate
	Make/n=(DegreeOfAggregation,3)/O MassFractalAggregate=0		// It starts at 0,0,0
	Make/n=(DegreeOfAggregation,4)/O endpoints							//List of end points
	make/N=(DegreeOfAggregation)/O Distances 							// Distance between existing particles & new one. Needed by MakeAgg
	variable StartTicks=ticks
	print time()+"  Started Run All" 
	IR3A_MakeAgg(DegreeOfAggregation,MassFractalAggregate,StickingProbability)		// Agg is made with DegreeOfAggregation particles
	IR3A_Ends(MassFractalAggregate)
	IR3A_Reted(endpoints)
	IR3A_Path(NumberOfTestPaths)
	IR3A_GizmoViewScatterPlot(MassFractalAggregate)
	print time()+"  Finished, done in "+num2str((ticks-StartTicks)/60)+" seconds" 	
	setDataFOlder OldDf
End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

Function IR3A_GrowAggregate()
	string OldDf=GetDataFolder(1)
	IR3A_InitializeMassFractAgg()
	SetDataFolder root:Packages:AggregateModeling

	NVAR DegreeOfAggregation=root:Packages:AggregateModeling:DegreeOfAggregation
	NVAR StickingProbability=root:Packages:AggregateModeling:StickingProbability
	variable DegreeOfAggregationL=DegreeOfAggregation
	VARIABLE StickingProbabilityL=StickingProbability
	Prompt DegreeOfAggregationL, "Enter the size of the aggregate (250)"
	Prompt StickingProbabilityL, "Enter StickingProbabilitying probability (1 - 100)"
	DoPrompt/Help="Basic parameters" "Input model parameters", DegreeOfAggregationL, StickingProbabilityL
	DegreeOfAggregation=DegreeOfAggregationL
	StickingProbability=StickingProbabilityL
	// Get the starting position of the aggregate
	Make/n=(DegreeOfAggregation,3)/O MassFractalAggregate=0		// It starts at 0,0,0
	make/N=(DegreeOfAggregation)/O Distances 	// Distance between existing particles & new one. Needed by MakeAgg
	IR3A_MakeAgg(DegreeOfAggregation,MassFractalAggregate,StickingProbability)		// Agg is made with DegreeOfAggregation particles
	setDataFOlder OldDf
End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
Function IR3A_InitializeMassFractAgg()

	IN2G_PrintDebugStatement(IrenaDebugLevel, 5,"")
	string OldDf=GetDataFolder(1)
	NewDataFolder/O/S root:Packages
	NewDataFolder/O/S root:Packages:AggregateModeling
	IR3A_MakeNBROffsetList()
	string/g ListOfVariables
	string/g ListOfStrings
	//here define the lists of variables and strings needed, separate names by ;...
	ListOfVariables="DegreeOfAggregation;StickingProbability;NumberOfTestPaths;BoxSize;"
	ListOfVariables+="pValue;dfValue;RValue;cValue;dminValue;sValue;AttemptValue;TrueStickingProbability;"
	ListOfVariables+="SelectedLevel;SelectedQlevel;SelectedBlevel;CurrentResults;StoredResults;"
	ListOfVariables+="BrFract_G2;BrFract_Rg2;BrFract_B2;BrFract_P2;BrFract_G1;BrFract_Rg1;BrFract_B1;BrFract_P1;BrFract_dmin;"
	ListOfVariables+="BrFract_c;BrFract_z;BrFract_fBr;BrFract_fM;"
	ListOfStrings="SlectedBranchedLevels;Model;BrFract_ErrorMessage;"
	Make/O/N=1/T Stored3DAggregates, Stored3DAggregatesPaths
	Make/O/N=1 Stored3DAggSelections
	Wave/T Stored3DAggregates
	Stored3DAggregates[0] = "Current model"
	variable i
	//and here we create them
	for(i=0;i<itemsInList(ListOfVariables);i+=1)	
		IN2G_CreateItem("variable",StringFromList(i,ListOfVariables))
	endfor												
	for(i=0;i<itemsInList(ListOfStrings);i+=1)	
		IN2G_CreateItem("string",StringFromList(i,ListOfStrings))
	endfor	
	NVAR DegreeOfAggregation
	if(DegreeOfAggregation<10)
		DegreeOfAggregation = 250
	endif
	NVAR StickingProbability
	if(StickingProbability<1 || StickingProbability>100)
		StickingProbability = 75
	endif
	NVAR NumberOfTestPaths
	if(NumberOfTestPaths<1000)
		NumberOfTestPaths = 2500
	endif
	NVAR CurrentResults
	NVAR StoredResults
	if(CurrentResults+StoredResults!=1)
		StoredResults =1
		CurrentResults = 0
	endif
	SVAR Model
	Model = "Branched mass fractal"

//	NVAR gdf, gR
//	variable/g gp = mom2,gc=ln(DegreeOfAggregation)/ln(gp),gdmin=gdf/gc,gs=round(exp(ln(DegreeOfAggregation)/gdmin))
		
	setDataFOlder OldDf
end
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

Function IR3A_MakeNBROffsetList()

	Make/n=(26,3)/O nghbrOfsetList
	Wave nghbrOfsetList = nghbrOfsetList
		nghbrOfsetList[0][0] =+1;nghbrOfsetList[0][1] = 0;nghbrOfsetList[0][2] = 0
		nghbrOfsetList[1][0] =-1;nghbrOfsetList[1][1] = 0;nghbrOfsetList[1][2] = 0
		nghbrOfsetList[2][0] = 0;nghbrOfsetList[2][1] =+1;nghbrOfsetList[2][2] = 0
		nghbrOfsetList[3][0] = 0;nghbrOfsetList[3][1] =-1;nghbrOfsetList[3][2] = 0
		nghbrOfsetList[4][0] =+1;nghbrOfsetList[4][1] =+1;nghbrOfsetList[4][2] = 0
		nghbrOfsetList[5][0] =-1;nghbrOfsetList[5][1] =-1;nghbrOfsetList[5][2] = 0
		nghbrOfsetList[6][0] =-1;nghbrOfsetList[6][1] =+1;nghbrOfsetList[6][2] = 0
		nghbrOfsetList[7][0] =+1;nghbrOfsetList[7][1] =-1;nghbrOfsetList[7][2] = 0
		nghbrOfsetList[8][0] = 0;nghbrOfsetList[8][1] = 0;nghbrOfsetList[8][2] =+1
		nghbrOfsetList[9][0] =+1;nghbrOfsetList[9][1] = 0;nghbrOfsetList[9][2] =+1
		nghbrOfsetList[10][0]=-1;nghbrOfsetList[10][1]= 0;nghbrOfsetList[10][2]=+1
		nghbrOfsetList[11][0]= 0;nghbrOfsetList[11][1]=+1;nghbrOfsetList[11][2]=+1
		nghbrOfsetList[12][0]= 0;nghbrOfsetList[12][1]=-1;nghbrOfsetList[12][2]=+1
		nghbrOfsetList[13][0]=+1;nghbrOfsetList[13][1]=+1;nghbrOfsetList[13][2]=+1
		nghbrOfsetList[14][0]=-1;nghbrOfsetList[14][1]=-1;nghbrOfsetList[14][2]=+1
		nghbrOfsetList[15][0]=-1;nghbrOfsetList[15][1]=+1;nghbrOfsetList[15][2]=+1
		nghbrOfsetList[16][0]=+1;nghbrOfsetList[16][1]=-1;nghbrOfsetList[16][2]=+1
		nghbrOfsetList[17][0]= 0;nghbrOfsetList[17][1]= 0;nghbrOfsetList[17][2]=-1
		nghbrOfsetList[18][0]=+1;nghbrOfsetList[18][1]= 0;nghbrOfsetList[18][2]=-1
		nghbrOfsetList[19][0]=-1;nghbrOfsetList[19][1]= 0;nghbrOfsetList[19][2]=-1
		nghbrOfsetList[20][0]= 0;nghbrOfsetList[20][1]=+1;nghbrOfsetList[20][2]=-1
		nghbrOfsetList[21][0]= 0;nghbrOfsetList[21][1]=-1;nghbrOfsetList[21][2]=-1
		nghbrOfsetList[22][0]=+1;nghbrOfsetList[22][1]=+1;nghbrOfsetList[22][2]=-1
		nghbrOfsetList[23][0]=-1;nghbrOfsetList[23][1]=-1;nghbrOfsetList[23][2]=-1
		nghbrOfsetList[24][0]=-1;nghbrOfsetList[24][1]=+1;nghbrOfsetList[24][2]=-1
		nghbrOfsetList[25][0]=+1;nghbrOfsetList[25][1]=-1;nghbrOfsetList[25][2]=-1

end
//******************************************************************************************************************************************************
//Function ProfilingRun()
//	string OldDf=GetDataFolder(1)
//	SetDataFolder root:Packages:AggregateModeling
//	AggMod_Initialize()
//
//	NVAR gGL
//	NVAR DegreeOfAggregation
//	NVAR StickingProbability
//	NVAR NumberOfTestPaths
//	
//	//variable GL=gGL, DegreeOfAggregation=DegreeOfAggregation, StickingProbability=StickingProbability, NumberOfTestPaths=NumberOfTestPaths
//	//Prompt DegreeOfAggregation, "Enter the size of the aggregate (250)"	// Degree of aggregation, z
//	//Prompt StickingProbability, "Enter StickingProbabilitying probability (1 - 100)"	// SP = 100% for DLA; less for RLA
//	//Prompt NumberOfTestPaths,"Enter number of paths (10000)."		// More paths = more accuracy
//	//DoPrompt/Help="Basic parameters" "Input model parameters", DegreeOfAggregation, StickingProbability, NumberOfTestPaths
//
//	gGL=500;DegreeOfAggregation=500;StickingProbability=40;NumberOfTestPaths=500;
//	// Get the starting position of the aggregate
//	Make/n=(DegreeOfAggregation,3)/O Agg=0		// It starts at 0,0,0
//	Make/n=(DegreeOfAggregation,4)/O endpoints
//	make/N=(DegreeOfAggregation)/O Distances 	// Distance between existing particles & new one. Needed by MakeAgg
//	variable StartTicks=ticks
//	print "Started Run All" 
//		MakeAgg(DegreeOfAggregation,Agg,StickingProbability)		// Agg is made with DegreeOfAggregation particles
//		Ends(agg)
//		Reted(endpoints)
//		Path(NumberOfTestPaths)
//		Execute("GizmoViewAggregate()")
//	print "Finished, done in "+num2str((ticks-StartTicks)/60)+" seconds" 	
//	setDataFOlder OldDf
//
//end

//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

Function IR3A_MakeAgg(DegreeOfAggregation,MassFractalAggregate,StickingProbability)
	variable DegreeOfAggregation,StickingProbability
	wave MassFractalAggregate
	
	string OldDf=GetDataFolder(1)
	SetDataFolder root:Packages:AggregateModeling
	Wave Distances
	make/Free/N=(dimsize(MassFractalAggregate,0),3) CurSite
	make/Free/N=(dimsize(MassFractalAggregate,0)) tmpCol
	variable chcnt=1,px,py,pz,aggct=1,cnt,con,stuck,dim,choice,wall,Rd=16,GL=16,farpoint,index=0, tmpVal
	NVAR AttemptValue
	AttemptValue=1
	NVAR BoxSize
	PauseUpdate
	Do
		// resize box based on size of Agg
		index=0
		do
			if(MassFractalAggregate[aggct-1][index]>farpoint)
				farpoint=MassFractalAggregate[aggct-1][index]
			endif
			index+=1
		while(index<3)
		GL=2*abs(farpoint)+10
		BoxSize=GL		
		// initialize particle on a random wall of the box
		wall=0;choice=0
		if(aggct<64)	// choose random wall on smaller box for low aggct
			do
				wall=abs(round(enoise(7)))
			while(wall==0 || wall==7)
			if(wall==1)
				px=-1+Rd/2;py=round(enoise(Rd/2));pz=round(enoise(Rd/2))
			endif
			if(wall==2)
				px=1-Rd/2;py=round(enoise(Rd/2));pz=round(enoise(Rd/2))
			endif
			if(wall==3)
				px=round(enoise(Rd/2));py=-1+Rd/2;pz=round(enoise(Rd/2))
			endif
			if(wall==4)
				px=round(enoise(Rd/2));py=1-Rd/2;pz=round(enoise(Rd/2))
			endif
			if(wall==5)
				px=round(enoise(Rd/2));py=round(enoise(Rd/2));pz=-1+Rd/2
			endif
			if(wall==6)
				px=round(enoise(Rd/2));py=round(enoise(Rd/2));pz=1-Rd/2
			endif
		else		// choose random wall on normal box
			do
				wall=abs(round(enoise(7)))
			while(wall==0 || wall==7)
			if(wall==1)
				px=-1+GL/2;py=round(enoise(GL/2));pz=round(enoise(GL/2))
			endif
			if(wall==2)
				px=1-GL/2;py=round(enoise(GL/2));pz=round(enoise(GL/2))
			endif
			if(wall==3)
				px=round(enoise(GL/2));py=-1+GL/2;pz=round(enoise(GL/2))
			endif
			if(wall==4)
				px=round(enoise(GL/2));py=1-GL/2;pz=round(enoise(GL/2))
			endif
			if(wall==5)
				px=round(enoise(GL/2));py=round(enoise(GL/2));pz=-1+GL/2
			endif
			if(wall==6)
				px=round(enoise(GL/2));py=round(enoise(GL/2));pz=1-GL/2
			endif
		endif
		// Move the particle until it a) hits the chain or b) leaves the box, if b) you need to have it reenter the box at a mirror position.
		do	//move 1 step in any direction
			//choice=0
			//do
			//choice=abs(round(enoise(7)))
			choice = floor(1 + mod(abs(enoise(100*6)),6))	
			//while(choice==0 || choice==7)
			if(choice==1)
				px+=1
			endif
			if(choice==2)	
				px-=1
			endif
			if(choice==3)	
				py+=1
			endif
			if(choice==4)
				py-=1
			endif
			if(choice==5)	
				pz+=1
			endif
			if(choice==6)	
				pz-=1
			endif
			//if you leave the box (a likely event) then go to the other side and reenter the box (mirror)
			If(aggct<64)	// use smaller box for low number of particles
				if(px>Rd/2)
					px=px-Rd
				endif
				if(px<-Rd/2)
					px=px+Rd
				endif
				if(py>Rd/2)
					py=py-Rd
				endif
				if(py<-Rd/2)
					py=py+Rd
				endif
				if(pz>Rd/2)
					pz=pz-Rd
				endif
				if(pz<-Rd/2)
					pz=pz+Rd
				endif	
			else		// use normal box for higher number of particles
				if(px>GL/2)
					px=px-GL
				endif
				if(px<-GL/2)
					px=px+GL
				endif
				if(py>GL/2)
					py=py-GL
				endif
				if(py<-GL/2)
					py=py+GL
				endif
				if(pz>GL/2)
					pz=pz-GL
				endif
				if(pz<-GL/2)
					pz=pz+GL
				endif
			endif
			cnt=0;con=0
			// check how many neighboring sites are occupied
			//this is by far the longest step in the whole procedure
			//basically, we are looking for how many neighbors px,py,pz position has 
			//this is already much better than before, but it would really be nice to find better way of doing this. We are doing this A LOT. With every particle move, so it is done many, many times. 
			Multithread Distances[0,aggct] = ((px-MassFractalAggregate[p][0])^2 + (py-MassFractalAggregate[p][1])^2 + (pz-MassFractalAggregate[p][2])^2)		//	Multithread helps, in my test case reduces time by ~60%
			//this is slower... 
			//CurSite[][0]=px
			//CurSite[][1]=py
			//CurSite[][2]=pz
			//MatrixOp/O/Free/NTHR=0 Distances = sumRows(powR((MassFractalAggregate-CurSite),2))
			Histogram/B={0.5,2.6,2}/R=[0,aggct]/Dest=DistHist Distances			//histogram - bin[0] is from 0.5 - 3.1, max allowed distance^2 is 3
			con = DistHist[0]																	// this is number of nearest neighbors with distance below sqrt(3)
			//another method, suggested by WM, but is slower, much slower ...
			//			CurSite[0][0]=px
			//			CurSite[0][1]=py
			//			CurSite[0][2]=pz
			//			MatrixOp/Free TestWv = catRows(CurSite,agg)
			//			FPClustering /DSO TestWv
			//			Wave M_DistanceMap
			//			//Edit/K=1 root:M_DistanceMap
			//			MatrixOp/Free Distances=row(M_DistanceMap,0)
			//			//Edit/K=1 root:Distances
			//			Histogram/B={0.1,1.8,2}/Dest=DistHist Distances
			//			//Edit/K=1 root:DistHist
			//			con = DistHist[0]
			// end of neighbor counting. 
			//choice=0
			if(con>=1)	// particle can StickingProbability if there is at least 1 neighbor
				do
					// apply StickingProbabilitying probability between 1% and 100%
					choice=floor(1 + mod(abs(enoise(100*99)),100))		//generates random integer from 1 to 99
					choice-=1
					AttemptValue+=1
					if(choice<=StickingProbability)
						stuck=1
						con=0
					else
						con-=1
						stuck=0
					endif
				while(con>=1)
			//keep moving if alone or rejected by StickingProbabilitying probability
			else
				stuck=0
			endif
			//if the particle StickingProbabilitys, add it to the aggregate
			variable steps=trunc(DegreeOfAggregation/10)
			steps = max(steps,100)
			if(stuck==1)
				if(mod(aggct,steps)<1) ///round(DegreeOfAggregation/50))==aggct/round(DegreeOfAggregation/50))
					Print time()+"  Added "+num2str(aggct)+" particles to the aggregate  "	//takes needless time.. 
				endif
				MassFractalAggregate[aggct][0]=px
				MassFractalAggregate[aggct][1]=py
				MassFractalAggregate[aggct][2]=pz
				aggct+=1
			endif
		while(stuck==0)
		stuck=0 //reset stuck flag
	While(aggct<DegreeOfAggregation)	// stop aggregate growth when there are DegreeOfAggregation particles in Agg
	Print time()+"  Created Aggregate with "+num2str(aggct)+" particles in it" 	//takes needless time.. 
	setDataFOlder OldDf

End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//		nghbr[0][0]=agg[cnt][0]+1;nghbr[0][1]=agg[cnt][1];nghbr[0][2]=agg[cnt][2]
//		nghbr[1][0]=agg[cnt][0]-1;nghbr[1][1]=agg[cnt][1];nghbr[1][2]=agg[cnt][2]
//		nghbr[2][0]=agg[cnt][0];nghbr[2][1]=agg[cnt][1]+1;nghbr[2][2]=agg[cnt][2]
//		nghbr[3][0]=agg[cnt][0];nghbr[3][1]=agg[cnt][1]-1;nghbr[3][2]=agg[cnt][2]
//		nghbr[4][0]=agg[cnt][0]+1;nghbr[4][1]=agg[cnt][1]+1;nghbr[4][2]=agg[cnt][2]
//		nghbr[5][0]=agg[cnt][0]-1;nghbr[5][1]=agg[cnt][1]-1;nghbr[5][2]=agg[cnt][2]
//		nghbr[6][0]=agg[cnt][0]-1;nghbr[6][1]=agg[cnt][1]+1;nghbr[6][2]=agg[cnt][2]
//		nghbr[7][0]=agg[cnt][0]+1;nghbr[7][1]=agg[cnt][1]-1;nghbr[7][2]=agg[cnt][2]
//		nghbr[8][0]=agg[cnt][0];nghbr[8][1]=agg[cnt][1];nghbr[8][2]=agg[cnt][2]+1
//		nghbr[9][0]=agg[cnt][0]+1;nghbr[9][1]=agg[cnt][1];nghbr[9][2]=agg[cnt][2]+1
//		nghbr[10][0]=agg[cnt][0]-1;nghbr[10][1]=agg[cnt][1];nghbr[10][2]=agg[cnt][2]+1
//		nghbr[11][0]=agg[cnt][0];nghbr[11][1]=agg[cnt][1]+1;nghbr[11][2]=agg[cnt][2]+1
//		nghbr[12][0]=agg[cnt][0];nghbr[12][1]=agg[cnt][1]-1;nghbr[12][2]=agg[cnt][2]+1
//		nghbr[13][0]=agg[cnt][0]+1;nghbr[13][1]=agg[cnt][1]+1;nghbr[13][2]=agg[cnt][2]+1
//		nghbr[14][0]=agg[cnt][0]-1;nghbr[14][1]=agg[cnt][1]-1;nghbr[14][2]=agg[cnt][2]+1
//		nghbr[15][0]=agg[cnt][0]-1;nghbr[15][1]=agg[cnt][1]+1;nghbr[15][2]=agg[cnt][2]+1
//		nghbr[16][0]=agg[cnt][0]+1;nghbr[16][1]=agg[cnt][1]-1;nghbr[16][2]=agg[cnt][2]+1
//		nghbr[17][0]=agg[cnt][0];nghbr[17][1]=agg[cnt][1];nghbr[17][2]=agg[cnt][2]-1
//		nghbr[18][0]=agg[cnt][0]+1;nghbr[18][1]=agg[cnt][1];nghbr[18][2]=agg[cnt][2]-1
//		nghbr[19][0]=agg[cnt][0]-1;nghbr[19][1]=agg[cnt][1];nghbr[19][2]=agg[cnt][2]-1
//		nghbr[20][0]=agg[cnt][0];nghbr[20][1]=agg[cnt][1]+1;nghbr[20][2]=agg[cnt][2]-1
//		nghbr[21][0]=agg[cnt][0];nghbr[21][1]=agg[cnt][1]-1;nghbr[21][2]=agg[cnt][2]-1
//		nghbr[22][0]=agg[cnt][0]+1;nghbr[22][1]=agg[cnt][1]+1;nghbr[22][2]=agg[cnt][2]-1
//		nghbr[23][0]=agg[cnt][0]-1;nghbr[23][1]=agg[cnt][1]-1;nghbr[23][2]=agg[cnt][2]-1
//		nghbr[24][0]=agg[cnt][0]-1;nghbr[24][1]=agg[cnt][1]+1;nghbr[24][2]=agg[cnt][2]-1
//		nghbr[25][0]=agg[cnt][0]+1;nghbr[25][1]=agg[cnt][1]-1;nghbr[25][2]=agg[cnt][2]-1
		// check neighboring points; add 1 connection for each neighboring point
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//Proc IR3A_FindEnds()	
//	Silent 1
//	Ends(MassFractalAggregate)
//End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Function IR3A_Ends(MassFractalAggregate)
	wave MassFractalAggregate

	string OldDf=GetDataFolder(1)
	SetDataFolder root:Packages:AggregateModeling
	NVAR DegreeOfAggregation

	variable cnt=0,ncnt=0,con=0,endcnt=0,dim=0
	Make/n=(26,3)/Free nghbr
	Wave/Z nghbrOfsetList
	if(!WaveExists(	nghbrOfsetList))
		IR3A_MakeNBROffsetList()
	endif
	Make/n=(DegreeOfAggregation,4)/o endpoints
	do
		// define neighbors for each point in agg
		nghbr = nghbrOfsetList[p][q] + MassFractalAggregate[cnt][q]
		ncnt=0;con=0
		do
			dim=0
			do
				if(nghbr[dim][0]==MassFractalAggregate[ncnt][0]&&nghbr[dim][1]==MassFractalAggregate[ncnt][1]&&nghbr[dim][2]==MassFractalAggregate[ncnt][2])
					con+=1
				endif
				dim+=1
			while(dim<26)
			ncnt+=1
		while(ncnt<DegreeOfAggregation)
		// it's an endpoint if there is exactly 1 neighboring point
		// record position in x, y, z and then record index in agg
		if(con==1)
			endpoints[endcnt][0]=MassFractalAggregate[cnt][0];endpoints[endcnt][1]=MassFractalAggregate[cnt][1];endpoints[endcnt][2]=MassFractalAggregate[cnt][2];endpoints[endcnt][3]=cnt
			endcnt+=1
		endif
		cnt+=1
		//Print cnt
	while(cnt<DegreeOfAggregation)
	//remove extra rows from endpoints wave
	DeletePoints endcnt,DegreeOfAggregation, endpoints
	setDataFOlder OldDf
	Print time()+"  Finished running Find Ends" 	//takes needless time.. 
	
End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

//Proc IR3A_EndtoEnd()	
//	Silent 1
//	Reted(endpoints)
//End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

Function IR3A_Reted(endpoints)
	wave endpoints
	// calculate longest end-to-end distance for each combination of endpoints and its square for weight-averaged end-to-end distance	
	string OldDf=GetDataFolder(1)
	SetDataFolder root:Packages:AggregateModeling
	NVAR DegreeOfAggregation
	NVAR RValue
	NVAR dfValue
	variable endnum=DimSize(endpoints,0), numcomb=binomial(endnum,2), cnt=0,endadd=0,ecnt=1,REnd=0,Rsum=0,Retend=0,RAve=0,rem=endnum
	Make/n=(numcomb,1)/o enddist=0
	Make/n=(endnum-3,7)/o Rlarge=0
	do	// determine end-to-end distance between all endpoints
		do
			enddist[endadd]=sqrt((endpoints[cnt][0]-endpoints[ecnt][0])^2+(endpoints[cnt][1]-endpoints[ecnt][1])^2+(endpoints[cnt][2]-endpoints[ecnt][2])^2)
			if(endnum-cnt>3)	
				if(enddist[endadd]>Rlarge[cnt][6])
					Rlarge[cnt][0]=endpoints[cnt][0];Rlarge[cnt][1]=endpoints[cnt][1];Rlarge[cnt][2]=endpoints[cnt][2]
					Rlarge[cnt][3]=endpoints[ecnt][0];Rlarge[cnt][4]=endpoints[ecnt][1];Rlarge[cnt][5]=endpoints[ecnt][2]
					Rlarge[cnt][6]=enddist[endadd]
				endif
			endif
			ecnt+=1
			endadd+=1
		while(ecnt<endnum)
		cnt+=1
		ecnt=cnt+1
	while(ecnt<endnum)
	cnt=0
	do	// calculate longest end-to-end distance for each combination of endpoints and its square for weight-averaged end-to-end distance
		REnd+=(Rlarge[cnt][6])*(Rlarge[cnt][6])
		RSum+=(Rlarge[cnt][6])
		cnt+=1
	while(cnt<endnum-3)
	RAve=RSum/cnt
	REnd/=RSum
	cnt=0
	// Print and record R, df
	Print "R = "+num2str(REnd)
	Print "df= "+num2str(log(DegreeOfAggregation)/log(REnd))
	RValue=Rend
	dfValue=log(DegreeOfAggregation)/log(REnd)

	setDataFOlder OldDf
End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

//Proc IR3A_FindPaths(NumberOfTestPaths)	
//	variable/g NumberOfTestPaths
//	variable NumberOfTestPaths=NumberOfTestPaths
//	Prompt NumberOfTestPaths,"Enter number of paths (10000)."
//	Silent 1
//	NumberOfTestPaths=NumberOfTestPaths
//	Path(NumberOfTestPaths)
//End



Function IR3A_Path(NumberOfTestPaths)
	variable NumberOfTestPaths

	string OldDf=GetDataFolder(1)
	SetDataFolder root:Packages:AggregateModeling
	print time()+"  Started parameters evaluation, Calculating...   this takes longest time for these functions "
	wave MassFractalAggregate
	Wave endpoints
	NVAR DegreeOfAggregation
	NVAR AttemptValue
	variable minPathLengthAccepted
	minPathLengthAccepted = floor(min(DegreeOfAggregation^(1/2), 20))		//minimum length opf path accpeted as evaluation path, for large particles original value is crazily large. 
	Make/n=(26,3)/Free nghbr
	Wave/Z nghbrOfsetList
	if(!WaveExists(nghbrOfsetList ))
		IR3A_MakeNBROffsetList()
	endif
	Make /n=(DegreeOfAggregation,26)/O NeighborList=nan
	Make/n=(DegreeOfAggregation,1)/Free Pathing=nan
	Make/n=(NumberOfTestPaths,7)/Free Paths=nan
	variable endnum=DimSize(endpoints,0), choice=0, cnt=0,ncnt=0,nnum=0,dim=0,con=0,pcnt=0,nans=0,flag=0,ecnt=0,highp,p1,p2,mom1,mom2,startpoint
	Make/n=(endnum,1)/O LongPath=0
	variable i
	MatrixOp/Free EndPointsDistances=col(endpoints,3)
	variable startTime=ticks
	For(cnt=0;cnt<DegreeOfAggregation;cnt+=1)
		nghbr = nghbrOfsetList[p][q] + MassFractalAggregate[cnt][q]					//this generates list of 26 neighbor positions, if any, around the agg[cnt] particle
		nnum=0
		For(ncnt=0;ncnt<DegreeOfAggregation;ncnt+=1)
			For(dim=0;dim<26;dim+=1)
				if(nghbr[dim][0]==MassFractalAggregate[ncnt][0]&&nghbr[dim][1]==MassFractalAggregate[ncnt][1]&&nghbr[dim][2]==MassFractalAggregate[ncnt][2])
					NeighborList[cnt][nnum]=ncnt			//cnt is external loop, cnt = 0 ...DegreeOfAggregation
					nnum+=1
				endif
			endfor
		endfor
	endfor
	cnt=0
	do	// snake through paths
		pcnt=0
		startpoint=floor(mod(abs(enoise(100*(endnum-1))),endnum))		//generates random integer from 0 to endnum
		// record starting position and starting index in agg
		Paths[cnt][0]=endpoints[startpoint][0]
		Paths[cnt][1]=endpoints[startpoint][1]
		Paths[cnt][2]=endpoints[startpoint][2]
		Pathing[0]=endpoints[startpoint][3]
		choice=0;con=0
		do	//pick a random neighbor from list
			ncnt=0
			nans=0
			flag=0
			//this is faster... 	
			For(i=0;i<8;i+=1)
				if(numtype(NeighborList[Pathing[pcnt]][i])==2)
					nans=8-i
					break
				endif
			endfor
			variable target= 8-nans-1
			choice=floor(mod(abs(enoise(100*target)),target+1))		//generates random number from non NaNs entries... 		
			ncnt=0
			do	// check to see if value already in path
				if(NeighborList[Pathing[pcnt]][choice]==Pathing[ncnt])
					flag+=1
				endif
				ncnt+=1
			while(ncnt<pcnt)
			if(flag>=2)	// is there a loop in the aggregate?
				con=1
			else		// add normally
				pcnt+=1
				Pathing[pcnt]=NeighborList[Pathing[pcnt-1]][choice]
			endif
			ncnt=1
			ecnt=0
			// this is about 2x faster...  EndPointsDistances was created above just once, it does not change. 
			FindValue /V=(Pathing[pcnt])/T=0.1 EndPointsDistances
			if(V_value>-0.1)
				con=1
			endif
			// (2) done... 			
		while(con!=1)
		if(pcnt>minPathLengthAccepted) 				// only interested in longer paths that span aggregate; throws away short paths
			Paths[cnt][3]=MassFractalAggregate[Pathing[pcnt]][0]
			Paths[cnt][4]=MassFractalAggregate[Pathing[pcnt]][1]
			Paths[cnt][5]=MassFractalAggregate[Pathing[pcnt]][2]
			Paths[cnt][6]=pcnt+1
			if(Paths[cnt][6]>LongPath[startpoint])
				LongPath[startpoint]=Paths[cnt][6]	
			endif
			cnt+=1
			//print "Evaluated path length of "+num2str(pcnt)
		else
			//print "Discarded path length of "+num2str(pcnt)
			continue
		endif
		if(mod(cnt,500)==0) 
			Print time()+"  Working... Evaluated "+num2str(cnt)+" Paths through the system"	//takes needless time.. 
		endif
	while(cnt<NumberOfTestPaths)
	ncnt=0;highp=0;p1=0;p2=0
	do	// determine weight-averaged percolation pathway
		if(LongPath[ncnt]>highp)
			highp=LongPAth[ncnt]
		endif
		p1+=(LongPath[ncnt])
		p2+=(LongPath[ncnt])*(LongPath[ncnt])
		ncnt+=1
	while(ncnt<endnum)
	mom2=round(p2/p1);mom1=round(p1/endnum)
	// print results
	NVAR dfValue
	NVAR RValue
	NVAR pValue
	NVAR sValue
	NVAR cValue
	NVAR dminValue
	NVAR TrueStickingProbability
	pValue = mom2
	cValue=ln(DegreeOfAggregation)/ln(pValue)
	dminValue=dfValue/cValue
	sValue=round(exp(ln(DegreeOfAggregation)/dminValue))
	TrueStickingProbability = 100*DegreeOfAggregation/AttemptValue
	Print "R = "+num2str(RValue)
	Print "z = "+num2str(DegreeOfAggregation)
	Print "p = "+num2str(pValue)
	Print "s = "+num2str(sValue)
	Print "df = "+num2str(dfValue)
	Print "dmin = "+num2str(dminValue)
	Print "c = "+num2str(cValue)
	Print "True Sticking Probability = "+num2str(100*DegreeOfAggregation/AttemptValue)+"%"
	//appned note to MassFractalAggregate
	string NoteText
	NoteText="Mass Fractal Aggregate created="+time()+";z="+num2str(DegreeOfAggregation)+";R="+num2str(RValue)+";p="+num2str(pValue)
	NoteText+=";s="+num2str(sValue)+";df="+num2str(dfValue)+";dmin="+num2str(dminValue)+";c="+num2str(cValue)+"True Sticking Probability="+num2str(100*DegreeOfAggregation/AttemptValue)+";"
	Note MassFractalAggregate, NoteText
	setDataFolder OldDf
End

//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Function IR3A_GetResults()
	string OldDf=GetDataFolder(1)
	SetDataFolder root:Packages:AggregateModeling
	NVAR DegreeOfAggregation
	NVAR RValue
	NVAR pValue
	NVAR dfValue
	NVAR dminValue
	NVAR cValue
	NVAR sValue
	NVAR AttemptValue
	cValue=ln(DegreeOfAggregation)/ln(pValue)
	dminValue=dfValue/cValue
	sValue=round(exp(ln(DegreeOfAggregation)/dminValue))
	Print "R= "+num2str(RValue)
	Print "df = "+num2str(dfValue)
	Print "z = "+num2str(DegreeOfAggregation)
	Print "p= "+num2str(pValue)
	Print "s = "+num2str(sValue)
	Print "dmin = "+num2str(dminValue)
	Print "c = "+num2str(cValue)
	Print "True Sticking Probability = "+num2str(100*DegreeOfAggregation/AttemptValue)+"%"
	setDataFOlder OldDf
End

//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Function IR3A_GizmoViewScatterPlot(ScatterPlotWave) : GizmoPlot
	wave ScatterPlotWave

	variable mnd = IR3A_GetAggMaxSize(ScatterPlotWave)
	variable boxSize=mnd+2		//make the box larger... 
	DoWIndow MassFractalAggregateView
	if(V_Flag)
		DoWIndow/F MassFractalAggregateView
		ModifyGizmo setOuterBox={-1*boxSize,boxSize,-1*boxSize,boxSize,-1*boxSize,boxSize}
		ModifyGizmo scalingOption=0
		ModifyGizmo modifyObject=Particle,objectType=Sphere,property={radius,1/mnd}
	else
		PauseUpdate; Silent 1		// building window...
		// Building Gizmo 7 window...
		NewGizmo/K=1/T="Mass Fractal Aggregate View"/W=(35,45,550,505)
		DoWIndow/C MassFractalAggregateView
		ModifyGizmo startRecMacro=700
		AppendToGizmo Scatter=ScatterPlotWave,name=scatter0
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ scatterColorType,0}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ markerType,0}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ sizeType,0}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ rotationType,0}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ Shape,2}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ size,1}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ color,1,0,0,1}
		//sphere as object definition:
		AppendToGizmo sphere={1/mnd,25,25},name=Particle
		ModifyGizmo modifyObject=Particle,objectType=Sphere,property={colorType,1}
		ModifyGizmo modifyObject=Particle,objectType=Sphere,property={color,0.000015,0.600000,0.304250,1.000000}
		AppendToGizmo attribute diffuse={0.5,0.5,0.5,1,1032},name=diffuse0
		ModifyGizmo attributeType=diffuse,modifyAttribute={diffuse0,0.733333,0.733333,0.733333,1,1032}
		ModifyGizmo modifyObject=Particle,objectType=Sphere,property={radius,1/mnd}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ Shape,7}
		ModifyGizmo ModifyObject=scatter0,objectType=scatter,property={ objectName,Particle}
		AppendToGizmo Axes=boxAxes,name=axes0
		ModifyGizmo ModifyObject=axes0,objectType=Axes,property={-1,axisScalingMode,1}
		ModifyGizmo ModifyObject=axes0,objectType=Axes,property={-1,axisColor,0,0,0,1}
		ModifyGizmo ModifyObject=axes0,objectType=Axes,property={0,ticks,3}
		ModifyGizmo ModifyObject=axes0,objectType=Axes,property={1,ticks,3}
		ModifyGizmo ModifyObject=axes0,objectType=Axes,property={2,ticks,3}
		ModifyGizmo modifyObject=axes0,objectType=Axes,property={-1,Clipped,0}
		AppendToGizmo light=Directional,name=LightFor3dView
		ModifyGizmo modifyObject=LightFor3dView,objectType=light,property={ position,0.000000,0.000000,-1.000000,0.000000}
		ModifyGizmo modifyObject=LightFor3dView,objectType=light,property={ direction,0.000000,0.000000,-1.000000}
		ModifyGizmo modifyObject=LightFor3dView,objectType=light,property={ ambient,0.400000,0.400000,0.400000,1.000000}
		ModifyGizmo modifyObject=LightFor3dView,objectType=light,property={ specular,1.000000,1.000000,1.000000,1.000000}
		ModifyGizmo modifyObject=LightFor3dView,objectType=light,property={ diffuse,0.933333,0.933333,0.933333,1.000000}
		ModifyGizmo modifyObject=LightFor3dView,objectType=light,property={ position,-0.6392,0.7354,0.2250,0.0000}
		ModifyGizmo modifyObject=LightFor3dView,objectType=light,property={ direction,-0.6392,0.7354,0.2250}
		ModifyGizmo setDisplayList=0, object=LightFor3dView
		ModifyGizmo setDisplayList=1, object=scatter0
		ModifyGizmo setDisplayList=2, object=axes0
		ModifyGizmo currentGroupObject=""
		//ModifyGizmo SETQUATERNION={0.535993,-0.191531,-0.283415,0.771818}
		//now scale this thing... 
		ModifyGizmo setOuterBox={-1*boxSize,boxSize,-1*boxSize,boxSize,-1*boxSize,boxSize}
		ModifyGizmo scalingOption=0
		Modifygizmo enhance
		//give user tools to work with
		//ModifyGizmo showInfo
		//ModifyGizmo infoWindow={350,550,822,320}
		ModifyGizmo resumeUpdates
		ModifyGizmo endRecMacro
		ModifyGizmo SETQUATERNION={-0.041312,-0.884834,-0.102589,0.452588}
	endif
	DoWindow FractalAggregatePanel
	if(V_Flag)
		AutoPositionWindow /M=0/R=FractalAggregatePanel MassFractalAggregateView
		//ModifyGizmo/N=MassFractalAggregateView infoWindow={350,550,822,520}
	endif

EndMacro
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Function IR3A_GetAggMaxSize(MassFractalAggregate)
	wave MassFractalAggregate
	
	WaveStats/Q MassFractalAggregate

	variable MaxNeeded=max(V_max, abs(V_min) )
	
	return MaxNeeded
end

//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Function IR3A_PopMenuProc(pa) : PopupMenuControl
	STRUCT WMPopupAction &pa

	NVAR SelectedLevel=root:Packages:AggregateModeling:SelectedLevel
	SVAR SlectedBranchedLevels=root:Packages:AggregateModeling:SlectedBranchedLevels
	NVAR SelectedQlevel=root:Packages:AggregateModeling:SelectedQlevel
	NVAR SelectedBlevel=root:Packages:AggregateModeling:SelectedBlevel

	switch( pa.eventCode )
		case 2: // mouse up
			Variable popNum = pa.popNum
			String popStr = pa.popStr
			string CtrlName=pa.ctrlName
			if(stringMatch(CtrlName,"AvailableLevels"))
				SelectedLevel = str2num(popStr[0,0])
				SlectedBranchedLevels=popStr
				//IR2U_SetControlsInPanel()
				IR3A_CalculateBranchedMassFr()
			endif
			if(stringMatch(CtrlName,"IntensityDataName")||stringMatch(CtrlName,"SelectDataFolder"))
				IR2C_PanelPopupControl(pa)		
				//SVAR Model=root:Packages:Irena_AnalUnifFit:Model
				//Model = "---"
				//Execute("PopupMenu Model,win=UnifiedEvaluationPanel, mode=1,popvalue=\"---\",value= root:Packages:Irena_AnalUnifFit:KnownModels")
				IR3A_SetControlsInPanel()	
				IR3A_FindAvailableLevels()
				IR3A_ClearVariables()
			endif	
			break
	endswitch

	return 0
End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Function IR3A_FindAvailableLevels()
	
	NVAR/Z UseCurrentResults=root:Packages:AggregateModeling:CurrentResults
	DoWIndow FractalAggregatePanel
	if(!NVAR_Exists(UseCurrentresults) || !V_Flag)
		return 0
	endif
	
	NVAR UseStoredResults=root:Packages:AggregateModeling:StoredResults
	String quote = "\""

	SVAR Model=root:Packages:AggregateModeling:Model
	variable LNumOfLevels, i
	
	if(UseCurrentResults)
		NVAR NumberOfLevels = root:Packages:Irena_UnifFit:NumberOfLevels
		LNumOfLevels = NumberOfLevels
	else
		LNumOfLevels =IR3A_ReturnNoteNumValue("NumberOfModelledLevels")	
	endif
	string AvailableLevels=""
	if(stringmatch(Model,"Branched mass fractal"))	
//		if(LNumOfLevels>=1)
//			AvailableLevels+=num2str(1)+";"
//		endif
		For(i=2;i<=LNumOfLevels;i+=1)
			AvailableLevels+=num2str(i)+"/"+num2str(i-1)+";"//+num2str(i)+";"
		endfor
	else
		AvailableLevels=""
//		For(i=1;i<=LNumOfLevels;i+=1)
//			AvailableLevels+=num2str(i)+";"
//		endfor
	endif
	string OnlyNumLevels=AvailableLevels
//	if(stringmatch(Model,"TwoPhase*"))	
//		AvailableLevels+="Range;All;"
//	endif	
//	if(stringmatch(Model,"Invariant*"))	
//		AvailableLevels+="Range;"
//	endif	
	AvailableLevels = quote + AvailableLevels + quote
	OnlyNumLevels = quote + OnlyNumLevels + quote
	NVAR SelectedQlevel=root:Packages:Irena_AnalUnifFit:SelectedQlevel
	NVAR SelectedBlevel=root:Packages:Irena_AnalUnifFit:SelectedBlevel
	SVAR SlectedBranchedLevels=root:Packages:Irena_AnalUnifFit:SlectedBranchedLevels
	string loQStr="---"
	if(SelectedQlevel>0)
		loQStr=num2str(SelectedQlevel)
	endif
	string hiQStr="---"
	if(SelectedBlevel>0)
		hiQStr=num2str(SelectedBlevel)
	endif
	string AvLevStr="---"
	if(stringmatch(AvailableLevels,"*"+SlectedBranchedLevels+"*"))
		AvLevStr=SlectedBranchedLevels
	endif
	PopupMenu AvailableLevels,win=FractalAggregatePanel,mode=1,popvalue= AvLevStr, value=#AvailableLevels
//	PopupMenu SelectedQlevel,win=FractalAggregatePanel,mode=1,popvalue=loQStr, value=#OnlyNumLevels
//	PopupMenu SelectedBlevel,win=FractalAggregatePanel,mode=1,popvalue=hiQStr, value=#OnlyNumLevels
end
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

 Function IR3A_ReturnNoteNumValue(KeyWord)
 	string KeyWord
 	
 	variable LUKVal
 	SVAR DataFolderName= root:Packages:AggregateModeling:DataFolderName
 	SVAR IntensityWaveName = root:Packages:AggregateModeling:IntensityWaveName
 	
 	Wave/Z LkpWv=$(DataFolderName+IntensityWaveName)
 	if(!WaveExists(LkpWv))
 		return NaN
 	endif
 	
 	LUKVal = NumberByKey(KeyWord, note(LkpWv)  , "=",";")
 	return LUKVal
 	
 end
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Function IR3A_CalculateBranchedMassFr()

	NVAR SelectedLevel = root:Packages:AggregateModeling:SelectedLevel
	SVAR SlectedBranchedLevels=root:Packages:AggregateModeling:SlectedBranchedLevels
	NVAR UseCurrentResults=root:Packages:AggregateModeling:CurrentResults
	NVAR UseStoredResults=root:Packages:AggregateModeling:StoredResults

	NVAR BrFract_G2=root:Packages:AggregateModeling:BrFract_G2
	NVAR BrFract_Rg2=root:Packages:AggregateModeling:BrFract_Rg2
	NVAR BrFract_B2=root:Packages:AggregateModeling:BrFract_B2
	NVAR BrFract_P2=root:Packages:AggregateModeling:BrFract_P2
	NVAR BrFract_G1=root:Packages:AggregateModeling:BrFract_G1
	NVAR BrFract_Rg1=root:Packages:AggregateModeling:BrFract_Rg1
	NVAR BrFract_B1=root:Packages:AggregateModeling:BrFract_B1
	NVAR BrFract_P1=root:Packages:AggregateModeling:BrFract_P1
	SVAR BrFract_ErrorMessage=root:Packages:AggregateModeling:BrFract_ErrorMessage
	NVAR BrFract_dmin=root:Packages:AggregateModeling:BrFract_dmin
	NVAR BrFract_c=root:Packages:AggregateModeling:BrFract_c
	NVAR BrFract_z=root:Packages:AggregateModeling:BrFract_z
	NVAR BrFract_fBr=root:Packages:AggregateModeling:BrFract_fBr
	NVAR BrFract_fM=root:Packages:AggregateModeling:BrFract_fM
	
	if(stringMatch(SlectedBranchedLevels,"2/1"))
		SelectedLevel = 2
	elseif(stringMatch(SlectedBranchedLevels,"3/2"))
		SelectedLevel = 3
	elseif(stringMatch(SlectedBranchedLevels,"4/3"))
		SelectedLevel = 4
	elseif(stringMatch(SlectedBranchedLevels,"5/4"))
		SelectedLevel = 5
	endif

	if(SelectedLevel>=2)
		if(UseCurrentResults)
			NVAR gG2=$("root:Packages:Irena_UnifFit:Level"+num2str(SelectedLevel)+"G")
			BrFract_G2 = gG2
			NVAR gRg2=$("root:Packages:Irena_UnifFit:Level"+num2str(SelectedLevel)+"Rg")
			BrFract_Rg2 = gRg2
			NVAR gB2=$("root:Packages:Irena_UnifFit:Level"+num2str(SelectedLevel)+"B")
			BrFract_B2 = gB2
			NVAR gP2=$("root:Packages:Irena_UnifFit:Level"+num2str(SelectedLevel)+"P")
			BrFract_P2 = gP2
			NVAR gG1=$("root:Packages:Irena_UnifFit:Level"+num2str(SelectedLevel-1)+"G")
			BrFract_G1 = gG1
			NVAR gRg1=$("root:Packages:Irena_UnifFit:Level"+num2str(SelectedLevel-1)+"Rg")
			BrFract_Rg1 = gRg1
			NVAR gB1=$("root:Packages:Irena_UnifFit:Level"+num2str(SelectedLevel-1)+"B")
			BrFract_B1 = gB1
			NVAR gP1=$("root:Packages:Irena_UnifFit:Level"+num2str(SelectedLevel-1)+"P")
			BrFract_P1 = gP1
		else
			//look up from wave note...
			BrFract_G2 = IR3A_ReturnNoteNumValue("Level"+num2str(SelectedLevel)+"G")
			BrFract_Rg2 = IR3A_ReturnNoteNumValue("Level"+num2str(SelectedLevel)+"Rg")
			BrFract_B2 = IR3A_ReturnNoteNumValue("Level"+num2str(SelectedLevel)+"B")
			BrFract_P2 = IR3A_ReturnNoteNumValue("Level"+num2str(SelectedLevel)+"P")
			BrFract_G1 = IR3A_ReturnNoteNumValue("Level"+num2str(SelectedLevel-1)+"G")
			BrFract_Rg1 = IR3A_ReturnNoteNumValue("Level"+num2str(SelectedLevel-1)+"Rg")
			BrFract_B1 = IR3A_ReturnNoteNumValue("Level"+num2str(SelectedLevel-1)+"B")
			BrFract_P1 = IR3A_ReturnNoteNumValue("Level"+num2str(SelectedLevel-1)+"P")
		endif
	elseif(SelectedLevel==1)
		if(UseCurrentResults)
			NVAR gG2=$("root:Packages:Irena_UnifFit:Level"+num2str(SelectedLevel)+"G")
			BrFract_G2 = gG2
			NVAR gRg2=$("root:Packages:Irena_UnifFit:Level"+num2str(SelectedLevel)+"Rg")
			BrFract_Rg2 = gRg2
			NVAR gB2=$("root:Packages:Irena_UnifFit:Level"+num2str(SelectedLevel)+"B")
			BrFract_B2 = gB2
			NVAR gP2=$("root:Packages:Irena_UnifFit:Level"+num2str(SelectedLevel)+"P")
			BrFract_P2 = gP2
			BrFract_G1 =0
			BrFract_Rg1 = 0
			BrFract_B1 =0
			BrFract_P1 = 0
		else
			//look up from wave note...
			BrFract_G2 = IR3A_ReturnNoteNumValue("Level"+num2str(SelectedLevel)+"G")
			BrFract_Rg2 = IR3A_ReturnNoteNumValue("Level"+num2str(SelectedLevel)+"Rg")
			BrFract_B2 = IR3A_ReturnNoteNumValue("Level"+num2str(SelectedLevel)+"B")
			BrFract_P2 = IR3A_ReturnNoteNumValue("Level"+num2str(SelectedLevel)+"P")
			BrFract_G1 = 0
			BrFract_Rg1 = 0
			BrFract_B1 = 0
			BrFract_P1 = 0
		endif
	else
			BrFract_G2 = 0
			BrFract_Rg2 = 0
			BrFract_B2 = 0
			BrFract_P2 = 0
			BrFract_G1 = 0
			BrFract_Rg1 = 0
			BrFract_B1 = 0
			BrFract_P1 = 0
	endif
	if(strlen(SlectedBranchedLevels)>1)
		BrFract_dmin  =BrFract_B2*BrFract_Rg2^(BrFract_P2)/(exp(gammln(BrFract_P2/2))*BrFract_G2)
		BrFract_c  =BrFract_P2/(BrFract_B2*BrFract_Rg2^(BrFract_P2)/(exp(gammln(BrFract_P2/2))*BrFract_G2))
		BrFract_z  =BrFract_G2/BrFract_G1 + 1 			//Greg, 11-24-2018: It should be G2/G1 +1  Karsten figured that out.  If G2 is 0 you still have one primary particle. 
		BrFract_fBr =(1-(BrFract_G2/BrFract_G1)^(1/(BrFract_P2/(BrFract_B2*BrFract_Rg2^(BrFract_P2)/(exp(gammln(BrFract_P2/2))*BrFract_G2)))-1))
		BrFract_fM  = (1-(BrFract_G2/BrFract_G1)^(1/((BrFract_B2*BrFract_Rg2^(BrFract_P2)/(exp(gammln(BrFract_P2/2))*BrFract_G2)))-1))
	else
		BrFract_dmin  =BrFract_B2*BrFract_Rg2^(BrFract_P2)/(exp(gammln(BrFract_P2/2))*BrFract_G2)
		BrFract_c  =BrFract_P2/(BrFract_B2*BrFract_Rg2^(BrFract_P2)/(exp(gammln(BrFract_P2/2))*BrFract_G2))
		BrFract_z  =Nan
		BrFract_fBr =NaN
		BrFract_fM  = NaN
	endif
	
	if(BrFract_c<0.96)
		BrFract_ErrorMessage =  "The mass fractal is too polydisperse to analyse, c < 1"
	else
		if(BrFract_c>=0.96 && BrFract_c<=1.04)//this should be in the range of 1 say +- .02
			BrFract_ErrorMessage = "THIS IS A LINEAR CHAIN WITH NO BRANCHES!"
		endif
		if(BrFract_c>=3)
			BrFract_ErrorMessage =  "There is a problem with the fit, c must be less than 3"
		endif
		if(BrFract_dmin>=3)
			BrFract_ErrorMessage = "There is a problem with the fit since dmin must be less than 3"
		endif
		if(BrFract_dmin>=0.96 && BrFract_dmin<=1.04 )//this should be in the range of 1 say +- .02
			BrFract_ErrorMessage = "This is a regular object, i.e.  c=1 rod, c=2 disk, c=3 sphere, etc."
		endif
	endif
	
	if(strlen(BrFract_ErrorMessage)>0)
		SetVariable BrFract_ErrorMessage, win=FractalAggregatePanel,  labelBack=(65535,49151,49151)
		beep
	else
		SetVariable BrFract_ErrorMessage, win=FractalAggregatePanel,  labelBack=0
	endif

end
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Function IR3A_CheckProc(cba) : CheckBoxControl
	STRUCT WMCheckboxAction &cba

	switch( cba.eventCode )
		case 2: // mouse up
			Variable checked = cba.checked
			NVAR CurrentResults=root:packages:AggregateModeling:CurrentResults
			NVAR StoredResults=root:packages:AggregateModeling:StoredResults
			SVAR Model=root:Packages:AggregateModeling:Model
			if(stringMatch(cba.ctrlName,"CurrentResults"))
				StoredResults=!CurrentResults
				//Button PrintToGraph, win=UnifiedEvaluationPanel, title="Print to Unified Fit Graph"
				//Button Invariantbutt, win=UnifiedEvaluationPanel, disable=0
			endif
			if(stringMatch(cba.ctrlName,"StoredResults"))
				CurrentResults=!StoredResults
				////Button PrintToGraph, win=UnifiedEvaluationPanel, title="Print to top Graph"
				//Button Invariantbutt, win=FractalAggregatePanel, disable=1
			endif
			//Model = "---"
			//PopupMenu Model,win=UnifiedEvaluationPanel, mode=1,popvalue="---",value= #"root:Packages:Irena_AnalUnifFit:KnownModels"
			IR3A_SetControlsInPanel()	
			IR3A_FindAvailableLevels()
			IR3A_ClearVariables()
			break
	endswitch

	return 0
End
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Function IR3A_SetControlsInPanel()

		SVAR Model=root:Packages:AggregateModeling:Model
		NVAR CurrentResults = root:packages:AggregateModeling:CurrentResults
		
		PopupMenu SelectDataFolder, win=FractalAggregatePanel, disable=CurrentResults
		PopupMenu IntensityDataName, win=FractalAggregatePanel, disable=CurrentResults
		Setvariable FolderMatchStr, win=FractalAggregatePanel, disable=CurrentResults

end

//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

Function IR3A_ClearVariables()


	NVAR BrFract_G2=root:Packages:AggregateModeling:BrFract_G2
	NVAR BrFract_Rg2=root:Packages:AggregateModeling:BrFract_Rg2
	NVAR BrFract_B2=root:Packages:AggregateModeling:BrFract_B2
	NVAR BrFract_P2=root:Packages:AggregateModeling:BrFract_P2
	NVAR BrFract_G1=root:Packages:AggregateModeling:BrFract_G1
	NVAR BrFract_Rg1=root:Packages:AggregateModeling:BrFract_Rg1
	NVAR BrFract_B1=root:Packages:AggregateModeling:BrFract_B1
	NVAR BrFract_P1=root:Packages:AggregateModeling:BrFract_P1
	SVAR BrFract_ErrorMessage=root:Packages:AggregateModeling:BrFract_ErrorMessage
	NVAR BrFract_dmin=root:Packages:AggregateModeling:BrFract_dmin
	NVAR BrFract_c=root:Packages:AggregateModeling:BrFract_c
	NVAR BrFract_z=root:Packages:AggregateModeling:BrFract_z
	NVAR BrFract_fBr=root:Packages:AggregateModeling:BrFract_fBr
	NVAR BrFract_fM=root:Packages:AggregateModeling:BrFract_fM
		BrFract_G2 = 0
		BrFract_Rg2 = 0
		BrFract_B2 = 0
		BrFract_P2 = 0
		BrFract_G1 = 0
		BrFract_Rg1 = 0
		BrFract_B1 = 0
		BrFract_P1 = 0
		BrFract_ErrorMessage=""
		BrFract_dmin=0
		BrFract_c=0
		BrFract_z=0
		BrFract_fBr=0
		BrFract_fM=0

end
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Function IR3A_PanelButtonProc(ba) : ButtonControl
	STRUCT WMButtonAction &ba

	switch( ba.eventCode )
		case 2: // mouse up
			// click code here
			if(stringmatch(ba.ctrlName,"CalculateAll"))
				IR3A_CalculateAllMassFractAgreg()
			endif
			if(stringmatch(ba.ctrlName,"Display3DMassFracGizmo"))
				IR3A_Display3DAggregate()
			endif
			if(stringmatch(ba.ctrlName,"SaveAggregateData"))
				IR3A_StoreCurrentMassFractAgreg()
				IR3A_Create3DAggListForListbox()
			endif
			break
		case -1: // control being killed
			break
	endswitch

	return 0
End

//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************


Function IR3A_StoreCurrentMassFractAgreg()
	string OldDf=GetDataFolder(1)
	SetDataFolder root:Packages:AggregateModeling
	NVAR OldDegreeOfAggregation=root:Packages:AggregateModeling:DegreeOfAggregation
	NVAR OldStickingProbability=root:Packages:AggregateModeling:StickingProbability
	NVAR OldRValue=root:Packages:AggregateModeling:RValue
	NVAR OldpValue=root:Packages:AggregateModeling:pValue
	NVAR OlddfValue=root:Packages:AggregateModeling:dfValue
	NVAR OlddminValue=root:Packages:AggregateModeling:dminValue
	NVAR OldcValue=root:Packages:AggregateModeling:cValue
	NVAR OldsValue=root:Packages:AggregateModeling:sValue
	NVAR OldAttemptValue=root:Packages:AggregateModeling:AttemptValue
	Wave/Z MSF=root:Packages:AggregateModeling:MassFractalAggregate
	if(WaveExists(MSF))
		string NewFolderName
		NewFolderName = "MFA_DOA_"+num2str(OldDegreeOfAggregation)+"_Stick_"+num2str(OldStickingProbability)+"_"
		NewDataFolder/O/S root:MassFractalAggregates
		NewFolderName = UniqueName(NewFolderName, 11, 0 )
		NewDataFolder/O/S $(NewFolderName)
		Duplicate/O MSF, MassFractalAggregate
		variable/g DegreeOfAggregation = OldDegreeOfAggregation
		variable/g StickingProbability = OldStickingProbability
		variable/g RValue = OldRValue
		variable/g pValue = OldpValue
		variable/g dfValue = OlddfValue
		variable/g dminValue = OlddminValue
		variable/g cValue = OldcValue
		variable/g sValue = OldsValue
		variable/g AttemptValue = OldAttemptValue		
	endif
	setDataFOlder OldDf


end
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************
//******************************************************************************************************************************************************

